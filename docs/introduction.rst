はじめに
========

SAPPOROBDD 2.0とは
------------------

SAPPOROBDD 2.0は、SAPPOROBDD++をベースに設計された新しい決定図（Decision Diagram）ライブラリです。
BDD（Binary Decision Diagram）とZDD（Zero-suppressed Decision Diagram）を効率的に操作するための
高性能なC++ライブラリを提供します。

.. tip::

   SAPPOROBDD++からの移行をお考えの方は :doc:`migration` をご覧ください。

決定図について
--------------

BDD（二分決定図）
~~~~~~~~~~~~~~~~~

BDDは、ブール関数を効率的に表現するデータ構造です。
各内部ノードは変数に対応し、0枝と1枝の2つの子を持ちます。

縮約BDDは以下の規則を満たします：

1. **ノード共有**: 等価なサブグラフは共有される
2. **冗長ノードの除去**: 0枝と1枝が同じノードを指す場合、そのノードは除去される

ZDD（ゼロ抑制二分決定図）
~~~~~~~~~~~~~~~~~~~~~~~~~

ZDDは、集合族（集合の集合）を効率的に表現するデータ構造です。
BDDとは異なる縮約規則を使用します：

1. **ノード共有**: 等価なサブグラフは共有される
2. **ゼロ抑制**: 1枝が終端0を指すノードは除去される

この縮約規則により、ZDDは疎な集合族を効率的に表現できます。

変数番号とレベル
----------------

SAPPOROBDD 2.0では、**変数番号（Variable Number）** と **レベル（Level）** を区別して管理します。

変数番号とは
~~~~~~~~~~~~

変数番号は、変数を識別するための一意の番号です。
``new_var()`` を呼び出すたびに、1から順番に割り当てられます。
変数番号は変数の作成順序を表し、変更されることはありません。

.. code-block:: cpp

   DDManager mgr;
   bddvar v1 = mgr.new_var();  // 変数番号 1
   bddvar v2 = mgr.new_var();  // 変数番号 2
   bddvar v3 = mgr.new_var();  // 変数番号 3

レベルとは
~~~~~~~~~~

レベルは、決定図内での変数の順序位置を表します。

**SAPPOROBDD規約**:

* **終端（Terminal）はレベル 0**
* **レベルが大きいほど根に近い** （根が最上位）
* **レベルが小さいほど終端に近い**

.. code-block:: text

   レベル 3: ───[v2]───  ← 根（最上位）
                /   \
   レベル 2: [v1]   [v1]
              / \   / \
   レベル 1: [v3] [v3] [v3] [v3]
              |   |   |   |
   レベル 0:  0   1   0   1   ← 終端

デフォルトでは、変数番号とレベルは同じ値になります（変数1はレベル1、変数2はレベル2、...）。

変数順序の変更
~~~~~~~~~~~~~~

``new_var_of_lev()`` を使用すると、指定したレベルに新しい変数を挿入できます。
既存の変数のレベルは自動的にシフトされます。

.. code-block:: cpp

   DDManager mgr;
   mgr.new_var();  // v1: レベル 1
   mgr.new_var();  // v2: レベル 2
   mgr.new_var();  // v3: レベル 3

   // レベル 2 に新しい変数を挿入
   mgr.new_var_of_lev(2);  // v4: レベル 2
   // v1: レベル 1（変わらず）
   // v2: レベル 3（シフト）
   // v3: レベル 4（シフト）
   // v4: レベル 2（新規）

TdZddとの連携
~~~~~~~~~~~~~

TdZddライブラリでは、specの ``get_root()`` が返すレベルは「根のレベル」を表し、
子に向かうほどレベルが減少します（レベル0が終端）。
これはSAPPOROBDD 2.0のレベル規約と同じです。

TdZddのレベル *L* は、SAPPOROBDD 2.0のレベル *L* に直接マッピングされます。

.. code-block:: cpp

   // TdZdd spec から ZDD を構築
   MySpec spec;
   ZDD zdd = sbdd2::tdzdd::build_zdd(mgr, spec);

ライブラリの特徴
----------------

128ビットノード構造
~~~~~~~~~~~~~~~~~~~

各ノードは128ビット（16バイト）で構成されています：

* **0-arc**: 44ビット（否定フラグ1ビット、定数フラグ1ビット、インデックス42ビット）
* **1-arc**: 44ビット（同上）
* **既約フラグ**: 1ビット
* **参照カウンタ**: 16ビット（飽和値65535）
* **変数番号**: 20ビット（最大約100万変数）

内部ハッシュ法
~~~~~~~~~~~~~~

ノードテーブルは内部ハッシュ法（二次探索）を使用します。
従来の外部連鎖法と比較して、キャッシュ効率が向上しています。

否定枝表現
~~~~~~~~~~

BDDでは否定枝表現を採用しています。
これにより、NOT演算がO(1)で実行可能になります。

スレッドセーフティ
~~~~~~~~~~~~~~~~~~

内部でmutexを使用し、マルチスレッド環境での安全な操作を保証します。

TdZdd互換インターフェース
~~~~~~~~~~~~~~~~~~~~~~~~~

TdZdd（岩下博明氏開発のフロンティア法ライブラリ）と互換性のある
Specインターフェースを提供します。既存のTdZdd用Specクラスを
そのまま使用してBDD/ZDDを構築できます。

並列ビルダー（OpenMP）もサポートしています。

厳密カウント（GMP）
~~~~~~~~~~~~~~~~~~~

GMPライブラリがインストールされている場合、``exact_count()`` メソッドで
任意精度の厳密なカウントが可能です。double精度（2^53）を超える
大規模な集合族でも正確なカウントを取得できます。

次のステップ
------------

* :doc:`quickstart` — インストールと基本的な使い方
* :doc:`guide/index` — DD種別ごとの詳細ガイド
* :doc:`application/index` — タスク指向の応用ガイド
* :doc:`examples/index` — サンプルコードの詳細解説
* :doc:`api/index` — APIリファレンス
