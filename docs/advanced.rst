高度なトピック
==============

内部アーキテクチャ
------------------

ノード構造
~~~~~~~~~~

SAPPOROBDD 2.0のノードは128ビット（16バイト）で構成されています。

.. code-block:: text

   Word 0 (64ビット):
   +-------------------+--------------------+
   |    0-arc (44)     | 1-arc下位 (20)     |
   +-------------------+--------------------+
     bits 0-43           bits 44-63

   Word 1 (64ビット):
   +-----------+---+--------+--------+-----+
   | 1-arc上位 | R | refcnt |  var   | rsv |
   +-----------+---+--------+--------+-----+
     bits 0-23   24  25-40    41-60   61-63

   R: 既約フラグ (1ビット)
   refcnt: 参照カウンタ (16ビット)
   var: 変数番号 (20ビット)
   rsv: 予約 (3ビット)

アーク構造
~~~~~~~~~~

各アークは44ビットで、以下の情報を保持します：

* **ビット0**: 否定フラグ
* **ビット1**: 定数フラグ（終端ノードかどうか）
* **ビット2-43**: ノードインデックス（42ビット、最大約4.4兆ノード）

内部ハッシュ法
~~~~~~~~~~~~~~

ノードの一意性を保証するために、内部ハッシュ法（二次探索）を使用しています。

.. code-block:: cpp

   // ハッシュ関数（FNV-1a風）
   size_t hash = 14695981039346656037ULL;
   hash ^= var;
   hash *= 1099511628211ULL;
   hash ^= arc0.data;
   hash *= 1099511628211ULL;
   hash ^= arc1.data;
   hash *= 1099511628211ULL;

   // 二次探索
   for (size_t i = 0; i < table_size; ++i) {
       size_t idx = (hash + i * i) % table_size;
       // ...
   }

メモリ管理
----------

参照カウント
~~~~~~~~~~~~

各ノードは16ビットの参照カウンタを持ちます。

* カウントが0になっても即座には解放されない（遅延回収）
* 最大値65535に達すると、以降は増減しない（永続ノード化）
* GC時に参照カウント0のノードが回収される

ガベージコレクション
~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // 手動GC
   mgr.gc();

   // 自動GC（内部的に呼ばれる）
   mgr.gc_if_needed();

GCは以下のタイミングで実行されます：

1. ノードテーブルの充填率が閾値を超えた場合
2. メモリ不足が検出された場合
3. 明示的に ``gc()`` が呼ばれた場合

演算キャッシュ
~~~~~~~~~~~~~~

演算結果は自動的にキャッシュされます。

.. code-block:: cpp

   // キャッシュをクリア
   mgr.cache_clear();

   // 統計情報
   std::cout << "キャッシュサイズ: " << mgr.cache_size() << std::endl;

パフォーマンスチューニング
--------------------------

テーブルサイズの最適化
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // 大規模な問題用に大きなテーブルを確保
   DDManager mgr(1 << 24, 1 << 22);  // 16Mノード、4Mキャッシュ

変数順序の重要性
~~~~~~~~~~~~~~~~

BDD/ZDDのサイズは変数順序に大きく依存します。
適切な変数順序を選択することで、指数関数的にサイズを削減できることがあります。

.. code-block:: cpp

   // 良い例: 関連する変数を近くに配置
   // 悪い例: ランダムな順序

   // 現在のライブラリでは静的な変数順序を使用
   // 将来のバージョンで動的リオーダリングをサポート予定

キャッシュ効率
~~~~~~~~~~~~~~

* 演算キャッシュは固定サイズのハッシュテーブル
* 衝突時は古いエントリを上書き
* 大規模な演算では適切なキャッシュサイズが重要

スレッドセーフティ
------------------

SAPPOROBDD 2.0はスレッドセーフです。

* ノードテーブルアクセスは ``table_mutex_`` で保護
* キャッシュアクセスは ``cache_mutex_`` で保護
* 変数カウンタは ``std::atomic`` を使用

.. code-block:: cpp

   // マルチスレッドでの使用例
   DDManager mgr;

   std::thread t1([&mgr]() {
       BDD x1 = mgr.var_bdd(1);
       BDD x2 = mgr.var_bdd(2);
       BDD f = x1 & x2;
   });

   std::thread t2([&mgr]() {
       BDD x3 = mgr.var_bdd(3);
       BDD x4 = mgr.var_bdd(4);
       BDD g = x3 | x4;
   });

   t1.join();
   t2.join();

注意点：

* 異なるマネージャー間でのBDD/ZDD操作は未定義動作
* 同じマネージャーを複数スレッドで共有する場合は正しく動作

例外処理
--------

SAPPOROBDD 2.0は以下の例外を使用します：

.. code-block:: cpp

   try {
       DDManager mgr;
       // 操作
   } catch (const DDMemoryException& e) {
       std::cerr << "メモリ不足: " << e.what() << std::endl;
   } catch (const DDArgumentException& e) {
       std::cerr << "不正な引数: " << e.what() << std::endl;
   } catch (const DDIOException& e) {
       std::cerr << "I/Oエラー: " << e.what() << std::endl;
   } catch (const DDException& e) {
       std::cerr << "その他のエラー: " << e.what() << std::endl;
   }
